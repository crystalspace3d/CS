<cgfp>
  <variablemap variable="light 0 diffuse" destination="DiffuseCol" />
  <variablemap variable="hair color" destination="objColor" />
  <variablemap variable="constants M" destination="constantsM" />  
  <program>
        <![CDATA[

struct vertex2fragment { 
	float4 HPosition : POSITION;
	float3 LightVec : TEXCOORD0;	
	float3 WorldNormal : TEXCOORD1;		
	float3 WorldView: TEXCOORD2;
	float3 AmbientColor: TEXCOORD3;	
};

float4 main (vertex2fragment IN,
			// Lookup tables for the hair model (fixed point)
			uniform sampler2D lookup1fixed,
			uniform sampler2D lookup2fixed,
			uniform float DiffuseCol,
			uniform float4 objColor,
			uniform float3 constantsM) : COLOR
{
	float4 OUT = float4(0, 0, 0, 1);
    DiffuseCol = 0.55;
	
	float MR_ct = constantsM.x;
	float MTT_ct = constantsM.y;
	float MTRT_ct = constantsM.z;
	
	float3 Ln = normalize(IN.LightVec);
	float3 Nn = normalize(IN.WorldNormal);
	float3 Vn = normalize(IN.WorldView);	
	
	float sin_qi = dot(Nn, Ln);
	float sin_qo = dot(Nn, Vn);
	
	/* Compute the longitudinal reflectance component */
	float2 uv1 = float2( sin_qi , sin_qo ) * 0.5 + 0.5;
	float4 M = tex2D(lookup1fixed, uv1);

	M.x *= MR_ct;
	M.y *= MTT_ct;
	M.z *= MTRT_ct;
	
	float3 lightPerp = normalize(Ln - sin_qi * Nn);
	float3 eyePerp = normalize(Vn - sin_qo * Nn);
	
	float cos_fd = dot( eyePerp, lightPerp ) * rsqrt( dot( eyePerp, eyePerp ) * dot( lightPerp, lightPerp ));
	float cos_qd = cos( ( asin( sin_qi ) - asin( sin_qo ) ) / 2.0 );
	//cos_qd = (M.w - 0.5) * 2.0;
	
    /* Compute the azimuthal reflectance component */
	float2 uv2 = float2( cos_fd, cos_qd ) * 0.5 + 0.5;
	float4 N = tex2D(lookup2fixed, uv2);
	
    /* Compute diffuse lighting with phi-dependent component */
    float diffuse = sqrt(max(0.0001, 1 - uv1.x * uv1.x));

    /* Pass colors */
	float4 diffuseColor;
    diffuseColor.rgb = diffuse * objColor.rgb * DiffuseCol;
    diffuseColor.a = objColor.a;
	
	float3 lighting = ( M.r * N.r + M.g * N.g + M.b * N.b ) /  max(0.2, cos_qd * cos_qd);
	lighting += diffuseColor.rgb;
	
	OUT.xyz = lighting + diffuseColor.rgb * 0.2 + IN.AmbientColor;
	
	//OUT.xyz = ( M.r * N.r + M.g * N.g + M.b * N.b ) / (cos_qd * cos_qd) + objColor.xyz;
	//OUT.xyz = ( M.r * N.r + M.g * N.g + M.b * N.b ) / max(0.2, cos_qd * cos_qd);
	//OUT.xyz = N.a;
	return OUT;
}

        ]]>
    </program>
</cgfp>
