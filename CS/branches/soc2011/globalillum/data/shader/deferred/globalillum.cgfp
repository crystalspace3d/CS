<cgfp>

<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="far clip distance" destination="farClipDistance" />
<variablemap variable="sample radius" destination="sampleRadius" />
<variablemap variable="sample count" destination="sampleCount" />
<variablemap variable="pattern size" destination="patternSize" />
<variablemap variable="depth bias" destination="depthBias" />
<variablemap variable="occlusion strength" destination="occlusionStrength" />
<variablemap variable="max occluder distance" destination="maxOccluderDistance" />
<variablemap variable="light rotation angle" destination="lightRotationAngle" />
<variablemap variable="bounce strength" destination="bounceStrength" />

<program>

<?Include /shader/deferred/light_common.cginc?>

<![CDATA[

const float PI             = 3.141592f;
const float TWO_PI         = 6.283185f;
const float ONE_OVER_PI    = 0.318310f;
const float ONE_OVER_TWOPI = 0.159155f;

struct vertex2fragment 
{
  float2 TexCoord : TEXCOORD0;
  float4 ScreenPos : TEXCOORD1;
  float4 ViewPos : TEXCOORD2;
};

float4 main(vertex2fragment IN,
            //uniform float4x4 Projection : state.matrix.projection,            
            //uniform float4x4 ProjInv, //: state.matrix.inverse.projection,
            uniform sampler2D DiffuseBuffer,
            uniform sampler2D NormalBuffer,
            uniform sampler2D AmbientBuffer,
            //uniform sampler2D DepthBuffer,
            uniform sampler2D DirectRadianceBuffer,                        
            uniform sampler2D EnvmapTexture,
            uniform sampler2D RandNormalsTexture,
            uniform float farClipDistance,
            uniform float sampleRadius,
            uniform int sampleCount,
            uniform int patternSize,
            uniform float depthBias,
            uniform float occlusionStrength,
            uniform float maxOccluderDistance,
            uniform float indirectLightStrength,
            uniform float lightRotationAngle,
            uniform float bounceStrength) : COLOR
{
	const float3 samples[8] =
	{
		normalize (float3 ( 1, 1, 1)) * 0.125f,
		normalize (float3 (-1,-1,-1)) * 0.250f,
		normalize (float3 (-1,-1, 1)) * 0.375f,
		normalize (float3 (-1, 1,-1)) * 0.500f,
		normalize (float3 (-1, 1 ,1)) * 0.625f,
		normalize (float3 ( 1,-1,-1)) * 0.750f,
		normalize (float3 ( 1,-1, 1)) * 0.875f,
		normalize (float3 ( 1, 1,-1)) * 0.999f
	};  
  
  float2 screenXY = IN.ScreenPos.xy / IN.ScreenPos.w;
  float2 texCoord = screenXY * 0.5f + 0.5f; //IN.TexCoord;  
  //float3 screen = GetScreenPosition (screenXY, tex2D (DepthBuffer, texCoord));
  //float3 pixelPosVS = ScreenToWorldPosition (screen, ProjInv);
  
  float3 diffuseColor = tex2D (DiffuseBuffer, texCoord).rgb;
  float3 ambientColor = tex2D (AmbientBuffer, texCoord).rgb;
  
  float4 normalDepthVS = tex2D (NormalBuffer, texCoord);
  float3 normalVS = normalDepthVS.rgb * 2.0f - 1.0f;
	float pixelDepth = normalDepthVS.a;  
  //farClipDistance = 29.8f;
	float depth = pixelDepth * farClipDistance;

	float3 kernelScale = float3 (sampleRadius / depth, sampleRadius / depth, sampleRadius / farClipDistance);

	float occlusion = 0.0f;
  float3 directRadiance = float3 (0.0f);
  float3 indirectRadiance = float3 (0.0f);

//#define NUM_PASSES 2

	for ( int j = 0; j < sampleCount; j++ )
	{
		float3 random = tex2D (RandNormalsTexture, texCoord * (patternSize + (float)j)).rgb;
		random = random * 2.0f - 1.0f;

		for ( int i = 0; i < 8; i++ )
		{
			float3 rotatedKernel = reflect (samples[i], random);
      if (dot (rotatedKernel, normalVS) < 0.0f)
        rotatedKernel = -1.0f * rotatedKernel;
        
      float3 normalizedRotatedKernel = normalize (rotatedKernel);
      rotatedKernel *= kernelScale;
      float2 sampleTexCoord = rotatedKernel.xy + texCoord;
      
      float4 sampleNormalDepthVS = tex2D (NormalBuffer, sampleTexCoord);
      float3 sampleNormalVS = sampleNormalDepthVS.xyz * 2.0f - 1.0f;
			float sampleDepth = sampleNormalDepthVS.a;
			//float fDelta = max (sampleDepth - (pixelDepth + rotatedKernel.z), 0.0f);
      //float deltaZ = pixelDepth - sampleDepth; //sampleDepth - (pixelDepth + rotatedKernel.z);
      float deltaZ = (pixelDepth + rotatedKernel.z) - sampleDepth;
      float deltaN = 1.0f - (dot (normalVS, sampleNormalVS));
      occlusion += occlusionStrength * step (depthBias, deltaZ) * deltaN * 
                    (1.0f - smoothstep (depthBias, maxOccluderDistance, deltaZ));
      
      // convert sample direction to spherical coords
      float theta = acos (normalizedRotatedKernel.y);
      float phi = atan2 (normalizedRotatedKernel.z, normalizedRotatedKernel.x);
      phi += lightRotationAngle;
      if (phi < 0) phi += TWO_PI;
      if (phi > TWO_PI) phi -= TWO_PI;
            
      float3 envmapRadiance = tex2D (EnvmapTexture, float2 (phi * ONE_OVER_TWOPI, 1.0 - theta * ONE_OVER_PI)).rgb;
      directRadiance += (1.0f - occlusion) * envmapRadiance * max (dot (normalVS, normalizedRotatedKernel), 0.0f);
      
      /*screenXY = (sampleTexCoord - 0.5f) * 2.0f;
      screen = GetScreenPosition (screenXY, tex2D (DepthBuffer, sampleTexCoord));
      float3 occluderPosVS = ScreenToWorldPosition (screen, ProjInv);
      
      // indirect radiance
      float3 occluderDir = occluderPosVS - pixelPosVS;
      float occluderDist = dot (occluderDir, occluderDir);
      occluderDir = normalize (occluderDir);
      float cosRi = max (0.0, dot (normalVS, occluderDir));
      float cosSi = max (0.0, dot (sampleNormalVS, -occluderDir));
      float occluderGeometricTerm = cosSi * cosRi / occluderDist; //(occluderDist * occluderDist);
      float3 occluderRadiance = tex2D (DirectRadianceBuffer, sampleTexCoord).rgb;
      indirectRadiance += bounceStrength * occluderRadiance * occluderGeometricTerm;*/
		}
	}

  float solidAngle = TWO_PI / (sampleCount * 8.0f);
	occlusion *= solidAngle;
  directRadiance *= solidAngle;
  //indirectRadiance *= solidAngle;
	
  //return float4 (indirectRadiance, 1.0f);
	return float4 (diffuseColor * bounceStrength * ambientColor * directRadiance, 1.0f - occlusion);
  //return float4 (directRadiance, 1.0f);
}

]]>
</program>
</cgfp>