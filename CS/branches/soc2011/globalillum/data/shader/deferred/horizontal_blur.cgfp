<cgfp>

<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="far clip distance" destination="FarClipDistance" />
<variablemap variable="inv viewport size" destination="InvViewportSize" />
<variablemap variable="ssao blur kernelsize" destination="KernelSize" />
<variablemap variable="ssao blur position threshold" destination="PositionThreshold" />
<variablemap variable="ssao blur normal threshold" destination="NormalThreshold" />

<program>

<?Include /shader/deferred/light_common.cginc?>

<![CDATA[

struct vertex2fragment 
{
  float4 ScreenPos : TEXCOORD0;
  float4 ViewPos : TEXCOORD1;
};

#define EPSILON 0.01f

float GaussianCoeff(float x, float sigma)
{
  return exp (-x * x / (2.0f * sigma * sigma));
}

float4 main(vertex2fragment IN,
            //uniform float4x4 ProjInv, //: state.matrix.inverse.projection,
            uniform sampler2D NormalBuffer,        
            //uniform sampler2D DepthBuffer,
            //uniform sampler2D DirectRadianceBuffer,
            uniform sampler2D GlobalIllumBuffer,
            uniform float FarClipDistance,
            uniform float2 InvViewportSize, // (1/viewport.width, 1/viewport.height)
            uniform int KernelSize,
            uniform float PositionThreshold,
            uniform float NormalThreshold) : COLOR
{
  float2 texCoord = (IN.ScreenPos.xy / IN.ScreenPos.w) * 0.5f + 0.5f;
  float4 normalDepthVS = tex2D (NormalBuffer, texCoord);
  float3 pixelNormalVS = normalDepthVS.rgb * 2.0f - 1.0f;
  float pixelDepth = normalDepthVS.a;
  
  float weightedAO = 0.0f;
  float AO = 0.0f;
  float3 weightedRadiance = float3(0.0f);
  float3 radiance = float3(0.0f);
  float weightSum = 0.0f;
  float gaussianSigma = KernelSize * 0.3333f;
  
	for (int i = -KernelSize; i <= KernelSize; i++)
	{
	  float2 sampleTexCoord = texCoord + float2 (i * InvViewportSize.x, 0.0f);
	  float4 sampleDepthNormalVS = tex2D (NormalBuffer, sampleTexCoord);
	  float3 sampleNormalVS = sampleDepthNormalVS.rgb * 2.0f - 1.0f;
	  float sampleDepth = sampleDepthNormalVS.a;
	  	  
	  float deltaZ = /*abs*/ (sampleDepth - pixelDepth);
    float dotN = dot (pixelNormalVS, sampleNormalVS);       
    float4 sampleGI = tex2D (GlobalIllumBuffer, sampleTexCoord);
    
	  if (deltaZ < PositionThreshold && dotN > 1.0f - NormalThreshold)
	  {      
      float totalWeight = GaussianCoeff (i, gaussianSigma); // * pow (dotN, 32.0f) / 
          //(EPSILON + deltaZ);
      //float totalWeight = exp (-i * i * NormalThreshold - deltaZ * deltaZ * PositionThreshold * 1024.0f);
      
      weightedAO += sampleGI.a * totalWeight;
      weightedRadiance += sampleGI.rgb * totalWeight;
      weightSum += totalWeight;
	  }
	  
	  AO += sampleGI.a;
	  radiance += sampleGI.rgb;
	}
  
  if (weightSum > 0.0f)
  {
    weightSum = 1.0f / weightSum;
    AO = weightedAO * weightSum;
    radiance = weightedRadiance * weightSum;
  }
  else
  {
    weightSum = 1.0f / (2.0f * KernelSize + 1.0f);
    AO *= weightSum;
    radiance *= weightSum;
  }
  
  //return tex2D (GlobalIllumBuffer, texCoord);
  return float4 (radiance, AO);
}            

]]>
</program>
</cgfp>
         