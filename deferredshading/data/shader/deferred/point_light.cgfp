<cgfp>

<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="light position view" destination="LightPos" />
<variablemap variable="light diffuse" destination="LightDiff" />
<variablemap variable="light specular" destination="LightSpec" />
<variablemap variable="light ambient" destination="LightAmbient" />
<variablemap variable="light attenuation" destination="AttenVec" />
  
<program>
<![CDATA[

float4x4 ProjInv;
 
struct vertex2fragment 
{
  float4 ScreenPos : TEXCOORD0;
};

// Computes linear attenuation.
float Attenuation_Linear(float d, float invLightRadius)
{
  return saturate (1 - d * invLightRadius);
}

// Computes constant, linear, quadratic (CLQ) attenuation.
float Attenuation_CLQ(float d, float3 coeff)
{
  return 1 / dot (float3 (1, d, d*d), coeff);
}

// Computes the attenuation for the current point light.
float Attenuation(float dist, float4 attenVec)
{
  float invAttenRadius = attenVec.w;
  
  if (invAttenRadius > 0)
    return Attenuation_Linear (dist, invAttenRadius);

  return Attenuation_CLQ (dist, attenVec.xyz);
}

// Extracts the depth from the given depth buffer sample.
float ExtractDepth(float4 depth)
{
  return 1 - 2 * depth.x;
}

// Unproject screen position.
float3 ScreenToWorldPosition(float3 screen)
{  
  float4 world = mul (ProjInv, float4 (screen, 1.0));
  return world.xyz / world.w;
}
 
float4 main(vertex2fragment IN,
            uniform float3 LightPos,
            uniform float3 LightDiff,
            uniform float3 LightSpec,
            uniform float3 LightAmbient,
            uniform float4 AttenVec,
            uniform sampler2D gBuffer0,
            uniform sampler2D gBuffer1,
            uniform sampler2D gBuffer2,
            uniform sampler2D gBufferDepth) : COLOR
{
  // Do the perspective divide and convert to texture space.
  float2 screenXY = IN.ScreenPos.xy / IN.ScreenPos.w;
  float2 screenUV = screenXY * 0.5 + 0.5;
  
  float4 albedo   = tex2D (gBuffer0, screenUV);
  float4 normal   = tex2D (gBuffer1, screenUV);
  float4 lightmap = tex2D (gBuffer2, screenUV);
  float4 depth    = tex2D (gBufferDepth, screenUV);
  
  float3 screen = float3 (screenXY.x, -screenXY.y, ExtractDepth (depth));
  float3 p = ScreenToWorldPosition (screen);
  float3 n = normal.xyz * 2.0 - 1.0;
  float3 L = LightPos - p;
  
  float dist = length (L);
  L = L / dist;
  
  // Since we are in view space we know that the eye position is at the origin.
  float3 V = -normalize (p); 
  float3 H = normalize (L + V);
  
  float att = Attenuation (dist, AttenVec);
  float specAmt = albedo.w;
  
  // Compute phong lighting.
  float3 diff = albedo.rgb * LightDiff * saturate (dot (n, L));
  float3 spec = LightSpec * specAmt * pow (saturate (dot (n, H)), 32);
  float3 color = (diff + spec) * att;

  return float4 (color, 1.0);
}

]]>
</program>
</cgfp>
