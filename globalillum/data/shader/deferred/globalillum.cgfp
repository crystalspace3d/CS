<cgfp>

<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="far clip distance" destination="farClipDistance" />
<variablemap variable="sample radius" destination="sampleRadius" />
<variablemap variable="sample count" destination="sampleCount" />
<variablemap variable="pattern size" destination="patternSize" />
<variablemap variable="depth bias" destination="depthBias" />
<variablemap variable="occlusion strength" destination="occlusionStrength" />
<variablemap variable="max occluder distance" destination="maxOccluderDistance" />
<variablemap variable="light rotation angle" destination="lightRotationAngle" />
<variablemap variable="bounce strength" destination="bounceStrength" />

<program>

<?Include /shader/deferred/light_common.cginc?>

<![CDATA[

const float PI             = 3.141592f;
const float TWO_PI         = 6.283185f;
const float ONE_OVER_PI    = 0.318310f;
const float ONE_OVER_TWOPI = 0.159155f;

float2 sampleTexCoord;
float3 sampleNormalVS;
float deltaZ;

struct vertex2fragment 
{
  float2 TexCoord : TEXCOORD0;
  float4 ScreenPos : TEXCOORD1;
  float4 ViewPos : TEXCOORD2;
};

float ComputeOcclusion(float2 texCoord, sampler2D NormalBuffer,
                       float3 rotatedKernel, float3 normalizedRotatedKernel,
                       float pixelDepth, float3 normalVS,
                       float occlusionStrength, float depthBias, float maxOccluderDistance)
{
  sampleTexCoord = rotatedKernel.xy + texCoord;      
  float4 sampleNormalDepthVS = tex2D (NormalBuffer, sampleTexCoord);
  //if (sampleNormalDepthVS.r == 0.0f && sampleNormalDepthVS.g == 0.0f && sampleNormalDepthVS.b == 0.0f)
  //  return 0.0f;
  
  sampleNormalVS = sampleNormalDepthVS.xyz * 2.0f - 1.0f;
  float sampleDepth = sampleNormalDepthVS.a;
  //float fDelta = max (sampleDepth - (pixelDepth + rotatedKernel.z), 0.0f);
  //float deltaZ = pixelDepth - sampleDepth; //sampleDepth - (pixelDepth + rotatedKernel.z);
  deltaZ = (pixelDepth + rotatedKernel.z) - sampleDepth;  
  float deltaN = 1.0f - max (0.0f, dot (normalVS, sampleNormalVS));
  return occlusionStrength * step (depthBias, deltaZ) * deltaN * 
    //(1.0f - max (0.0f, dot (normalizedRotatedKernel, normalVS) - depthBias)) * 
    (1.0f - smoothstep (depthBias, maxOccluderDistance, deltaZ));
}

float4 main(vertex2fragment IN,
            //uniform float4x4 Projection : state.matrix.projection,            
            //uniform float4x4 ProjInv, //: state.matrix.inverse.projection,
            uniform sampler2D DiffuseBuffer,
            uniform sampler2D NormalBuffer,
            uniform sampler2D AmbientBuffer,
            //uniform sampler2D DepthBuffer,
            uniform sampler2D DirectRadianceBuffer,                        
            uniform sampler2D EnvmapTexture,
            uniform sampler2D RandNormalsTexture,
            uniform float farClipDistance,
            uniform float sampleRadius,
            uniform int sampleCount,
            uniform int patternSize,
            uniform float depthBias,
            uniform float occlusionStrength,
            uniform float maxOccluderDistance,
            uniform float indirectLightStrength,
            uniform float lightRotationAngle,
            uniform float bounceStrength) : COLOR
{  
	const float3 samples[8] =
	{
		normalize (float3 ( 1, 1, 1)) * 0.5625f, //0.125f,
		normalize (float3 (-1,-1,-1)) * 0.6250f, //0.250f,
		normalize (float3 (-1,-1, 1)) * 0.6875f, //0.375f,
		normalize (float3 (-1, 1,-1)) * 0.7500f, //0.500f,
		normalize (float3 (-1, 1 ,1)) * 0.8125f, //0.625f,
		normalize (float3 ( 1,-1,-1)) * 0.8750f, //0.750f,
		normalize (float3 ( 1,-1, 1)) * 0.9375f, //0.875f,
		normalize (float3 ( 1, 1,-1)) * 1.0000f //0.999f
	};
  /*const float3 samples[16] =
	{
		float3(0.355512, 	-0.709318, 	-0.102371),
		float3(0.534186, 	0.71511, 	-0.115167),
		float3(-0.87866, 	0.157139, 	-0.115167),
		float3(0.140679, 	-0.475516, 	-0.0639818),
		float3(-0.0796121, 	0.158842, 	-0.677075),
		float3(-0.0759516, 	-0.101676, 	-0.483625),
		float3(0.12493, 	-0.0223423,	-0.483625),
		float3(-0.0720074, 	0.243395, 	-0.967251),
		float3(-0.207641, 	0.414286, 	0.187755),
		float3(-0.277332, 	-0.371262, 	0.187755),
		float3(0.63864, 	-0.114214, 	0.262857),
		float3(-0.184051, 	0.622119, 	0.262857),
		float3(0.110007, 	-0.219486, 	0.435574),
		float3(0.235085, 	0.314707, 	0.696918),
		float3(-0.290012, 	0.0518654, 	0.522688),
		float3(0.0975089, 	-0.329594, 	0.609803)
	};*/
  
  float2 screenXY = IN.ScreenPos.xy / IN.ScreenPos.w;
  float2 texCoord = screenXY * 0.5f + 0.5f; //IN.TexCoord;  
  //float3 screen = GetScreenPosition (screenXY, tex2D (DepthBuffer, texCoord));
  //float3 pixelPosVS = ScreenToWorldPosition (screen, ProjInv);
  
  //float3 diffuseColor = tex2D (DiffuseBuffer, texCoord).rgb;
  //float3 ambientColor = tex2D (AmbientBuffer, texCoord).rgb;
  
  float4 normalDepthVS = tex2D (NormalBuffer, texCoord);
  //if (normalDepthVS.r == 0.0f && normalDepthVS.g == 0.0f && normalDepthVS.b == 0.0f)
  //  return float4(0.0f, 0.0f, 0.0f, 1.0f);
  
  float3 normalVS = normalDepthVS.rgb * 2.0f - 1.0f;
	float pixelDepth = normalDepthVS.a;
  //farClipDistance = 29.8f;
	float depth = pixelDepth * farClipDistance;
  float3 pixelPos = float3 (screenXY.x, -screenXY.y, pixelDepth);

	float3 kernelScale = float3 (sampleRadius / depth, sampleRadius / depth, sampleRadius / farClipDistance);

	float occlusion = 0.0f;
  float3 directRadiance = float3 (0.0f);
  float3 indirectRadiance = float3 (0.0f);

//#define NUM_PASSES 2

	for ( int j = 0; j < sampleCount; j++ )
	{
		float3 random = tex2D (RandNormalsTexture, texCoord * (float2(16,12) + (float)j)).rgb;
		random = random * 2.0f - 1.0f;

		for ( int i = 0; i < 8/*16*/; i++ )
		{
			float3 rotatedKernel = reflect (samples[i], random);
      if (dot (rotatedKernel, normalVS) < 0.0f)
        rotatedKernel = -rotatedKernel;
        
      float3 normalizedRotatedKernel = normalize (rotatedKernel);
      rotatedKernel *= kernelScale;
      
      occlusion += ComputeOcclusion(texCoord, NormalBuffer, rotatedKernel, normalizedRotatedKernel,
                      pixelDepth, normalVS, occlusionStrength, depthBias, maxOccluderDistance);
      occlusion += ComputeOcclusion(texCoord, NormalBuffer, rotatedKernel * 4.0f, normalizedRotatedKernel,
                      pixelDepth, normalVS, occlusionStrength, depthBias, maxOccluderDistance);
      
      // convert sample direction to spherical coords
      /*float theta = acos (normalizedRotatedKernel.y);
      float phi = atan2 (normalizedRotatedKernel.z, normalizedRotatedKernel.x);
      phi += lightRotationAngle;
      if (phi < 0) phi += TWO_PI;
      if (phi > TWO_PI) phi -= TWO_PI;
            
      float3 envmapRadiance = tex2D (EnvmapTexture, float2 (phi * ONE_OVER_TWOPI, 1.0 - theta * ONE_OVER_PI)).rgb;
      directRadiance += (1.0f - occlusion) * envmapRadiance * max (dot (normalVS, normalizedRotatedKernel), 0.0f);*/
      
      //float2 sampleScreenXY = (sampleTexCoord - 0.5f) * 2.0f;
      //float3 occluderPos = float3 (sampleScreenXY.x, -sampleScreenXY.y, sampleDepth);
      //screen = GetScreenPosition (screenXY, tex2D (DepthBuffer, sampleTexCoord));
      //float3 occluderPosVS = ScreenToWorldPosition (screen, ProjInv);
      
      // indirect radiance
      /*float3 occluderDir = normalizedRotatedKernel; //occluderPos - pixelPos;
      float occluderDist = max (1.0f, deltaZ * farClipDistance); //max (1.0f, dot (occluderDir, occluderDir));
      //occluderDir = normalize (occluderDir);
      float cosRi = max (0.0, dot (normalVS, occluderDir));
      float cosSi = max (0.0, dot (sampleNormalVS, -occluderDir));
      float occluderGeometricTerm = cosSi * cosRi / (occluderDist * occluderDist);
      float3 occluderRadiance = tex2D (DirectRadianceBuffer, sampleTexCoord).rgb;
      indirectRadiance += bounceStrength * occluderRadiance * occluderGeometricTerm * occlusion;*/
		}
	}

  float invTotalSamples = PI / /*16.0f*/(sampleCount * 16.0f);
	occlusion *= invTotalSamples;
  //directRadiance *= invTotalSamples;
  indirectRadiance *= invTotalSamples;
	
  //return float4 (indirectRadiance, 1.0f);
  occlusion = max (1.0f - occlusion, 0.01f);
	return float4 (indirectRadiance, occlusion);
  //return float4 (directRadiance, 1.0f);
}

]]>
</program>
</cgfp>