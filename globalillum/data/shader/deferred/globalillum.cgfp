<cgfp>

<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="sample radius" destination="sampleRadius" />
<variablemap variable="sample count" destination="sampleCount" />
<variablemap variable="pattern size" destination="patternSize" />
<variablemap variable="depth bias" destination="depthBias" />
<variablemap variable="occlusion strength" destination="occlusionStrength" />
<variablemap variable="max occluder distance" destination="maxOccluderDistance" />
<variablemap variable="light rotation angle" destination="lightRotationAngle" />

<program>

<?Include /shader/deferred/light_common.cginc?>

<![CDATA[

const float PI             = 3.141592;
const float TWO_PI         = 6.283185;
const float ONE_OVER_PI    = 0.318310;
const float ONE_OVER_TWOPI = 0.159155;

struct vertex2fragment 
{
  float4 ScreenPos : TEXCOORD0;
  float4 ViewPos : TEXCOORD1;
};

// compute the local frame
float3x3 ComputeTripodMatrix(const float3 direction, const float3 up) 
{
	float3 tangent = normalize (cross (up, direction));
	float3 cotangent = normalize (cross (direction, tangent));
	return float3x3 (tangent, cotangent, direction);
}

float ComputeOcclusion(float x, float maxOccluderDistance, float occlusionStrength)
{
  //if (x > maxOccluderDistance)
  //  return 1.0f;
  //else
    return 1.0f - occlusionStrength / (1.0f + x * x);
    //return 1.0f - occlusionStrength * smoothstep (0.0f, maxOccluderDistance, x);
}

float4 main(vertex2fragment IN,
            uniform float4x4 Projection : state.matrix.projection,
            uniform float4x4 ModelView : state.matrix.modelview,
            uniform float4x4 ProjInv, //: state.matrix.inverse.projection,
            uniform sampler2D NormalBuffer,
            uniform sampler2D DepthBuffer,
            uniform sampler2D DirectRadianceBuffer,
            uniform sampler2D SeedTexture,
            //uniform samplerCUBE EnvmapTexture
            uniform sampler2D EnvmapTexture,
            uniform sampler2D RandNormalsTexture,
            uniform float sampleRadius,
            uniform int sampleCount,
            uniform int patternSize,
            uniform float depthBias,
            uniform float occlusionStrength,
            uniform float maxOccluderDistance,
            uniform float lightRotationAngle) : COLOR
{
  float4 samples[16] =
	{
		float4(0.355512, 	-0.709318, 	-0.102371,	0.0 ),
		float4(0.534186, 	0.71511, 	-0.115167,	0.0 ),
		float4(-0.87866, 	0.157139, 	-0.115167,	0.0 ),
		float4(0.140679, 	-0.475516, 	-0.0639818,	0.0 ),
		float4(-0.0796121, 	0.158842, 	-0.677075,	0.0 ),
		float4(-0.0759516, 	-0.101676, 	-0.483625,	0.0 ),
		float4(0.12493, 	-0.0223423,	-0.483625,	0.0 ),
		float4(-0.0720074, 	0.243395, 	-0.967251,	0.0 ),
		float4(-0.207641, 	0.414286, 	0.187755,	0.0 ),
		float4(-0.277332, 	-0.371262, 	0.187755,	0.0 ),
		float4(0.63864, 	-0.114214, 	0.262857,	0.0 ),
		float4(-0.184051, 	0.622119, 	0.262857,	0.0 ),
		float4(0.110007, 	-0.219486, 	0.435574,	0.0 ),
		float4(0.235085, 	0.314707, 	0.696918,	0.0 ),
		float4(-0.290012, 	0.0518654, 	0.522688,	0.0 ),
		float4(0.0975089, 	-0.329594, 	0.609803,	0.0 )
	};

  // Do the perspective divide and convert to texture space.
  float2 screenXY = IN.ScreenPos.xy / IN.ScreenPos.w;
  float2 screenUV = screenXY * 0.5 + 0.5;
  
  float3 diffuseColor = tex2D (DirectRadianceBuffer, screenUV).rgb;
  
  float4 depth = tex2D (DepthBuffer, screenUV);  
  float3 screen = GetScreenPosition (screenXY, depth);  

  // view space position and normal of the current pixel
  float3 pixelPos = ScreenToWorldPosition (screen, ProjInv);
  float sampleDepth = -pixelPos.z;
  
  float4 bufferNormal = tex2D (NormalBuffer, screenUV);
  //float normalizedDepth = bufferNormal.a;  
  //float3 viewDir = IN.ViewPos.xyz;
  //float3 pixelPos = viewDir * normalizedDepth;
  
  float3 pixelNormal = ExtractNormal (bufferNormal);
  
  // accumulate direct radiance
  float3 directRadiance = float3 (0.0);
  float3 indirectRadiance = float3 (0.0);
  float ambientOcclusion = 0.0;
  
  float3 randomNormal = tex2D (RandNormalsTexture, screenUV * patternSize).rgb;
  //return float4(randomNormal, 1.0);
  
  for (int i=0; i < 16; i++)
  {        
    float3 sample = reflect (samples[i].xyz, randomNormal);
    if (dot (sample, pixelNormal) < 0.0)
      sample = -sample;
    
    float3 normalizedSample = normalize (sample);
    
    float3 samplePos = pixelPos + sampleRadius * sample;    

    // back-project to eye space and convert to texture space
    float4 screenSamplePos = mul (Projection, float4 (samplePos, 1.0));
    screenXY = screenSamplePos.xy / screenSamplePos.w;
    screenUV = screenXY * 0.5 + 0.5;
    
    depth = tex2D (DepthBuffer, screenUV);
    screen = GetScreenPosition (screenXY, depth);

    // view space position and normal of the sample
    float3 occluderPos = ScreenToWorldPosition (screen, ProjInv);
    float3 occluderNormal = ExtractNormal (tex2D (NormalBuffer, screenUV));    

    // direct radiance    
    float occluderDepth = -occluderPos.z - depthBias;
    float depthDiff = abs (occluderDepth - sampleDepth);
    
    //float distanceTerm = 1.0 - step (maxOccluderDistance, abs (depthDiff));
    //if (abs (depthDiff) >= maxOccluderDistance)
    //  distanceTerm = 0.0;
    
    //float occlusion = max (0.0, depthDiff);
    float visibility; // = ComputeOcclusion (max (0.0, depthDiff), maxOccluderDistance, occlusionStrength);
    if (depthDiff > maxOccluderDistance) 
      visibility = 1.0;
    else
      visibility = 1.0 - occlusionStrength / (1.0 + depthDiff * depthDiff);
    
    float receiverGeometricTerm = max (0.0, dot (normalizedSample, pixelNormal));
    
    // convert sample direction to spherical coords
    float theta = acos (normalizedSample.y);
    float phi = atan2 (normalizedSample.z, normalizedSample.x);
    phi += lightRotationAngle;
    if (phi < 0) phi += TWO_PI;
    if (phi > TWO_PI) phi -= TWO_PI;
          
    float3 envmapRadiance = tex2D (EnvmapTexture, float2 (phi * ONE_OVER_TWOPI, 1.0 - theta * ONE_OVER_PI)).rgb;
    //float3 envmapRadiance = texCUBE (EnvmapTexture, sample).rgb;
    
    directRadiance += saturate(envmapRadiance) * visibility * receiverGeometricTerm;
    ambientOcclusion += visibility;
    
    // indirect radiance
    /*float3 occluderDir = occluderPos - pixelPos;
    float occluderDist = saturate (length (occluderDir));
    occluderDir = normalize (occluderDir);
    float cosRi = max (0.0, dot (pixelNormal, occluderDir));
    float cosSi = max (0.0, dot (occluderNormal, -occluderDir));
    float geometricTerm = cosSi * cosRi / (occluderDist * occluderDist);
    indirectRadiance += diffuse * (1 - occlusion) * geometricTerm;*/
  }
  
  //directRadiance = max (float3 (0.0), directRadiance);
  
  ambientOcclusion /= 16;
  directRadiance /= 16;
  
  return float4 (float3 (ambientOcclusion), 1.0);
  //return float4 (directRadiance /** diffuseColor*/, 1.0);
}            

]]>
</program>
</cgfp>
         