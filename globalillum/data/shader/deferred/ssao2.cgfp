<cgfp>
<variablemap variable="projection transform inverse" destination="ProjInv" />
<variablemap variable="far clip distance" destination="farClipDistance" />
<variablemap variable="sample radius" destination="sampleRadius" />
<variablemap variable="sample count" destination="sampleCount" />
<variablemap variable="pattern size" destination="patternSize" />
<variablemap variable="depth bias" destination="depthBias" />
<variablemap variable="occlusion strength" destination="occlusionStrength" />
<variablemap variable="max occluder distance" destination="maxOccluderDistance" />
<variablemap variable="light rotation angle" destination="lightRotationAngle" />

<program>
<?Include /shader/deferred/light_common.cginc?>
<![CDATA[

uniform float4x4 Projection : state.matrix.projection;
uniform float4x4 ModelView : state.matrix.modelview;
uniform float4x4 ProjInv; //: state.matrix.inverse.projection,
uniform sampler2D DiffuseBuffer;
uniform sampler2D NormalBuffer;
uniform sampler2D AmbientBuffer;
uniform sampler2D DepthBuffer;
uniform sampler2D DirectRadianceBuffer;
uniform sampler2D SeedTexture;
uniform sampler2D EnvmapTexture;
uniform sampler2D RandNormalsTexture;
uniform float farClipDistance;
uniform float sampleRadius;
uniform int sampleCount;
uniform int patternSize;
uniform float depthBias;
uniform float occlusionStrength;
uniform float maxOccluderDistance;
uniform float indirectLightStrength;
uniform float lightRotationAngle;

struct vertex2fragment 
{
  float2 TexCoord : TEXCOORD0;
  float4 ScreenPos : TEXCOORD1;
  float4 ViewPos : TEXCOORD2;
};

float ComputeOcclusion(float2 texCoord, float3 ray, float3 scale, float3 screenPos, float3 normal)
{
  ray *= scale;
  float2 sampleTC = texCoord + ray.xy;
  float4 sampleNormalDepth = tex2D (NormalBuffer, sampleTC);
  float2 sampleXY = (sampleTC - 0.5) * 2.0;
  float sampleDepth = sampleNormalDepth.a * farClipDistance;
  
  float3 sampleScreenPos = float3 (sampleXY.x, -sampleXY.y, sampleDepth);
  float3 sampleNormal = sampleNormalDepth.rgb * 2.0 - 1.0;
  
  float3 vecToOccluder = sampleScreenPos - screenPos;
  float distance = length (vecToOccluder);
  float deltaN = (1.0 - max (0.0, dot (normal, sampleNormal))) * 
      max (0.0 - depthBias, dot (normal, normalize (vecToOccluder)) - lightRotationAngle);
  return step (0.0, distance) /** step (distance, maxOccluderDistance)*/ * deltaN * occlusionStrength 
      // / (1.0 + distance);
      * (1.0f - smoothstep (0.0, maxOccluderDistance, distance));
  
  /*float fRangeIsInvalid = saturate((screenPos.z - sampleDepth) / scale.z);			
  // accumulate accessibility, use default value of 0.5 if right computations are not possible
  return lerp (sampleDepth > (screenPos.z + ray.z), 0.1, fRangeIsInvalid) * deltaN * 
      occlusionStrength * step (fRangeIsInvalid, maxOccluderDistance);*/
}

float4 main(vertex2fragment IN) : COLOR
{  
  const float3 samples[8] =
	{
		normalize (float3 ( 1, 1, 1)) * 0.5625f, //0.125f,
		normalize (float3 (-1,-1,-1)) * 0.6250f, //0.250f,
		normalize (float3 (-1,-1, 1)) * 0.6875f, //0.375f,
		normalize (float3 (-1, 1,-1)) * 0.7500f, //0.500f,
		normalize (float3 (-1, 1 ,1)) * 0.8125f, //0.625f,
		normalize (float3 ( 1,-1,-1)) * 0.8750f, //0.750f,
		normalize (float3 ( 1,-1, 1)) * 0.9375f, //0.875f,
		normalize (float3 ( 1, 1,-1)) * 0.9999f //0.999f
	};
	/*const float2 samples[4] =
	{
		float2 ( 1, 0) * 0.625, 
    float2 (-1, 0) * 0.750,
    float2 ( 0, 1) * 0.875, 
    float2 (0, -1)
  };*/
  
  float2 screenXY = IN.ScreenPos.xy / IN.ScreenPos.w;
  float2 texCoord = screenXY * 0.5 + 0.5;
  
  float4 normalDepth = tex2D (NormalBuffer, texCoord);
  float depth = normalDepth.a * farClipDistance;
  float3 screenPos = float3 (screenXY.x, -screenXY.y, depth);
  float3 normal = normalDepth.rgb * 2.0 - 1.0;
  float3 randomNormal = tex2D (RandNormalsTexture, texCoord * float2(1024, 768) / 16).rgb * 2.0 - 1.0;
  //randomNormal = normalize (randomNormal);
  
  float3 scale = float3 (sampleRadius / depth, sampleRadius / depth, sampleRadius / farClipDistance);
  float AO = 0.0;
  float n = 0;
  for (n=0; n < sampleCount / 8; n++)
  {    
    for (int i=0; i < 8; i++)
    {
      float3 ray = reflect (samples[i], randomNormal);
      if (dot (ray, normal) < 0.0)
        ray = -ray;        
          
      AO += ComputeOcclusion (texCoord, ray, scale, screenPos, normal);    
    }
  }
  
  AO /= n * 8.0;
  AO += depthBias;
  return float4 (float3(0.0), 1.0 - saturate(AO));
}

]]>
</program>
</cgfp>