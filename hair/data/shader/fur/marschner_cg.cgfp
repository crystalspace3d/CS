<cgfp>
  <variablemap variable="mat furcolor" destination="FurColor" />
  <program>
        <![CDATA[
        
static const float PI = 3.14159265f;
static const float EPS = 0.0001f;

struct vertex2fragment { 
	float4 Position : POSITION;
	float4 LightDir : TEXCOORD0;
	float4 EyeVec : TEXCOORD1;
};

float3 EuclidianToSpherical (float3 vector)
{
	return float3( atan( vector[1], vector[0] ), PI/2 - acos( vector[2] ), 0 );
}

float BravaisIndex( float theta, float eta )
{
	float sinTheta = sin( theta );
	return sqrt( eta * eta - sinTheta * sinTheta ) / cos( theta );
}

float TargetAngle( float p, float differenceAzimuth )
{
	float targetAngle = abs(differenceAzimuth);

	if ( p != 1 )
	{
		// [-PI,PI]
		if ( targetAngle > PI )
			targetAngle -= 2 * PI;

		// offset center
		targetAngle += p * PI;
	}
	
	return targetAngle;
}

//Gaussian distribution - http://en.wikipedia.org/wiki/Normal_distribution
float GaussianDistribution(float sigma, float x_mu)
{
	return (1 / ( sigma * sqrt( 2 * PI ) )) * exp( - x_mu * x_mu  / ( 2 * sigma * sigma ) );
}

// Fresnel equation Rs - http://en.wikipedia.org/wiki/Fresnel_equations
float FresnelRs (float n1, float n2, float angle)
{
	float Rs = 1;
	float theta = abs(angle);
	
	if ( theta > PI/2 )
		theta = PI - theta;
	
	float a = ( n1 / n2 ) * sin( theta );
	a *= a;
	
	if ( a <= 1 )
	{
		float b = n2 * sqrt( 1 - a );
		float c = n1 * cos( theta );
		Rs =  ( c - b ) / ( c + b );
		Rs *= Rs;
		Rs = min( 1, Rs );
	}	
	
	return Rs;
}

// Fresnel equation Rp - http://en.wikipedia.org/wiki/Fresnel_equations
float FresnelRp (float n1, float n2, float angle)
{
	float Rp = 1;
	float theta = abs(angle);
	
	if ( theta > PI/2 )
		theta = PI - theta;
	
	float a = ( n1 / n2 ) * sin( theta );
	a *= a;
	
	if ( a <= 1 )
	{
		float b = n1 * sqrt( 1 - a );
		float c = n2 * cos( theta );
		Rp =  ( b - c ) / ( b + c );
		Rp *= Rp;
		Rp = min( 1, Rp );
	}	
	
	return Rp;
}

// Fresnel equation R - http://en.wikipedia.org/wiki/Fresnel_equations
float Fresnel (float n1S, float n2S, float n1P, float n2P, float angle)
{
	return 0.5 * ( FresnelRs(n1S, n2S, angle) + FresnelRp(n1P, n2P, angle) );
}

// Solve a * x + b = 0
float4 LinearSolver (uniform float a, uniform float b)
{
	float4 roots = 0;
	
	if ( abs(a) > EPS )
	{
		roots[0] = -b / a;
		roots[3] = 1;
	}
	
	return roots;
}

// Solve a * x ^ 2 + b * x + c = 0
float4 QuadraticSolver (uniform float a, uniform float b, uniform float c)
{
	float4 roots = 0;
	
	if ( abs(a) < EPS )
		return LinearSolver(b, c);
	else
	{
		float D = b * b - 4 * a * c;
		
		if ( abs(D) < EPS )
		{
			roots[0] = -b / ( 2 * a );
			roots[3] = 1;
		}
		else if (D > 0)
		{
			float delta = sqrt(D);
			roots[0] = (-b + delta) / (2 * a);
			roots[1] = (-b - delta) / (2 * a);
			roots[3] = 2;
		}
	}
	
	return roots;
}

// Solve x ^ 3 + A * x ^ 2 + B * x + C = 0 - http://en.wikipedia.org/wiki/Cubic_function
float4 NormalizedCubicSolver (uniform float A, uniform float B, uniform float C)
{
	float4 roots = 0;
	
	if ( abs(C) < EPS )	//	x = 0 solution
		return QuadraticSolver (1, A, B);
	else
	{
		float Q = (3 * B - A * A) / 9;
		float R = (9 * A * B - 27 * C - 2 * A * A * A ) / 54;
		float D = Q * Q * Q + R * R;
		
		if (D > 0)	// 1 root
		{
			float sqrtD = sqrt (D);
			float s = sign(R + sqrtD) * pow( abs(R + sqrtD), 1.0f / 3.0f );
			float t = sign(R - sqrtD) * pow( abs(R - sqrtD), 1.0f / 3.0f );
			
			roots[0] = ( -A / 3 + (s + t) );
			roots[3] = 1;
		}
		else	// 3 roots
		{
			float theta = acos( R / sqrt( -(Q * Q * Q)) );
			float sqrtQ = sqrt( -Q );
			roots[0] = (2 * sqrtQ * cos(theta / 3) - A / 3);
			roots[1] = (2 * sqrtQ * cos( (theta + 2 * PI) / 3) - A / 3);
			roots[2] = (2 * sqrtQ * cos( (theta + 4 * PI) / 3) - A / 3);
			roots[3] = 3;
		}
	}
	
	return roots;
}

// Solve a * x ^ 3 + b * x ^ 2 + c * x  + d = 0 - http://en.wikipedia.org/wiki/Cubic_function
float4 CubicSolver (uniform float a, uniform float b, uniform float c, uniform float d)
{
	float4 roots = 0;	//	root[3] - length
	
	if ( abs(a) < EPS )
		roots = QuadraticSolver (b, c, d);
	else
		roots = NormalizedCubicSolver(b / a, c / a, d / a);
		
	return roots;
}

// computes the derivative of the polynomial relative to h.
float DerivateAnglePolynomial( float p, float eta, float h )
{
	float gamma = asin( h );
	float c = asin(1 / eta);
	float dGamma = (6 * p * c / PI - 2) - 3 * 8 * ( p * c / (PI * PI * PI) ) * gamma * gamma;
	float denominator = sqrt(1 - h * h);
	
	return dGamma / max(EPS, denominator);
}

// Solve o(p,y) - targetAngle = 0
float4 Roots (uniform float p, uniform float eta, uniform float targetAngle)
{
	//o(p,y) = (6pc / PI - 2)y - 8(pc/PI^3)y^3 + pPI, c = asin( 1/eta )^-1
	float c = asin(1 / eta);
	//c = 0.0001f;
	return CubicSolver( -8 * ( p * c / (PI * PI * PI) ), 0, ( 6 * p * c / PI - 2 ), p * PI - targetAngle );	
	//return LinearSolver( -2, - targetAngle );	
}

float3 A(float3 absorption, float3 light, float p, float gammaI, float refraction, float etaPerpendicular, float etaParallel)
{
	//A(0; h) = F(h0; h00; gi)
	
	if ( p == 0 )
		return Fresnel(1, etaPerpendicular, 1, etaParallel, gammaI);

	//A(p; h) = ( (1 - F(h0; h00; gi) ) ^ 2 ) * ( F(1 / h0; 1 / h00; gi) ^ (p - 1) ) * ( T(s0a; h) ^ p )
	
	float h = sin( gammaI );	// sin gi = h
	float gammaT = asin(h / etaPerpendicular);	// h0 sin gt = h
	float thetaT = acos( (etaPerpendicular / refraction) * cos( light[1] ) );	// l = ls / cos qt = 2r cos h0t / cos qt
	float cosThetaT = cos(thetaT);
	float l = 2 * cos( gammaT ) / cosThetaT;	// l = ls / cos qt = 2r cos h0t / cos qt
	float3 segmentAbsorption = float3( exp( -absorption[0] * l * p ), 
									   exp( -absorption[1] * l * p ), 
									   exp( -absorption[2] * l * p ) );

	// FresnelTT = (1 - aR) * (1 - Fresnel(1/h0, 1/h00, gi) )
	float invFresnel = Fresnel( etaPerpendicular, 1, etaParallel, 1, gammaT );
	float fresnel = ( 1 - Fresnel(1, etaPerpendicular, 1, etaParallel, gammaI) ) * ( 1 - invFresnel );
	//FresnelTRT = FresnelTT * Fresnel(1/h0, 1/h00, gi)
	if ( p > 1 )
		fresnel = fresnel * invFresnel;
		
	return fresnel * segmentAbsorption;
}

// functions implementing Marschner
float M( float shift, float width, float averageTheta)
{
	// g(bR;qh-aR)
	return GaussianDistribution(width, averageTheta - shift);
}

// Equation (8)
float3 NP (float3 absorption, float3 light, float p, float refraction, float etaPerpendicular, float etaParallel, float targetAngle )
{
	float4 roots = Roots (p, etaPerpendicular, targetAngle);
	float3 result = 0;

	// roots.w is not good some times ?!
	roots[3] = 3;
	for (float index = 0; index < roots[3] ; index+=1 )
	{
		float gammaI = roots[index];
		
		if ( abs(gammaI) <= PI / 2 )
		{
			float h = sin( gammaI );
			float3 finalAbsorption = A( absorption, light, p, gammaI, refraction, etaPerpendicular, etaParallel );
			float derivateAngle = DerivateAnglePolynomial( p, etaPerpendicular, h );
			float denominator = max( EPS, 2 * abs( derivateAngle ) );
			
			result += (finalAbsorption / denominator);
		}
	}
	
	return result;
}
		
float4 main (vertex2fragment IN,
			uniform float4 FurColor) : COLOR
{
	//Fiber properties
	float refraction = 1.55;
	float3 absorption = 0.2;
	float eccentricity = 0.85;

	//Surface properties
	float shiftR = -10; 
	float shiftTT = -shiftR/2;
	float shiftTRT = -3*shiftR/2;
	float widthR = 5;
	float widthTT = widthR/2;
	float widthTRT = 2*widthR;
	
	//Glints
	float glintScale = 0.5;
	float causticWidth = 10;
	float causticFade = 0.2;
	float causticLimit = 0.5;

	//Turn into spherical coordinates
	float3 eye = EuclidianToSpherical(IN.EyeVec);
	float3 light = EuclidianToSpherical(IN.LightDir);
	
	//Compute params for M
	float differenceTheta = abs( eye[1] - light[1] ) / 2;
	float halfTheta = ( eye[1] + light[1] ) / 2;
	
	float MR = M( shiftR, widthR, halfTheta );
	float MTT = M( shiftTT, widthTT, halfTheta );
	float MTRT = M( shiftTRT, widthTRT, halfTheta );

	//Computer params for NP and NTT
	float etaPerpendicular = BravaisIndex( differenceTheta, refraction );
	float etaParallel = (refraction * refraction) / etaPerpendicular;	
	float differenceAzimuth = mod( abs( eye[0] - light[0] ), 2 * PI );
	//differenceAzimuth = 0;
	float cosDifferenceTheta = cos( differenceTheta );
	float invSqrCosDifferenceTheta = 1 / (cosDifferenceTheta * cosDifferenceTheta);
	float cosLight = cos( light[1] );
	float finalScale = invSqrCosDifferenceTheta * cosLight;

	float3 NR = NP( absorption, light, 0, refraction, etaPerpendicular, etaParallel, TargetAngle(0, differenceAzimuth) );
	float3 NTT = NP( absorption, light, 1, refraction, etaPerpendicular, etaParallel, TargetAngle(1, differenceAzimuth) );	
	
	//float4 roots = Roots (1, etaPerpendicular, TargetAngle(1, differenceAzimuth));
	
	float4 OUT = 0;
	//OUT.xyz += NR * 1000;
	//OUT.xyz += NTT * finalScale;
	OUT.xyz = (MTT + MR + MTRT) * finalScale * 15 * FurColor;
	
	return OUT;
	//Fresnel(1, 1, 1, 1, 1.4f);	
	//A(1, light, 1, 3, 1, 1, 1);
	//return CubicSolver(1, -1, 1, -1);
	//return float4(0.5,0,0,1);
	//return FurColor;
}

        ]]>
    </program>
</cgfp>
