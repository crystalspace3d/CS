<?xml version="1.0" encoding="utf-8" ?> 
<!--
  Copyright (C) 2011 by Alexandru Voicu
      (C) 2007-2008 by Frank Richter
	    (C) 2007 by Jorrit Tyberghein

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Library General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Library General Public License for more details.

  You should have received a copy of the GNU Library General Public
  License along with this library; if not, write to the Free
  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-->
<shader compiler="xmlshader" name="shadow_osm">
  <technique priority="200">
    <pass>
      <combiner plugin="crystalspace.graphics3d.shader.combiner.glcg" />
      <mixmode><add/></mixmode>
      <texture name="tex diffuse" destination="TexDiffuse" />
      <texture name="light shadow map" destination="DepthMap" />
      <vp plugin="glcg">
        <cgvp>
          <program>
          <![CDATA[
          
          struct app2vertex {
            float4 Position : POSITION;
            float2 TexCoord : TEXCOORD0;
          };
          struct vertex2fragment {
            float4 Hposition : POSITION;
            float2 TexCoord : TEXCOORD0;
            float4 position_camera : TEXCOORD1;
          };          
          
          vertex2fragment main (app2vertex IN,
            uniform float4x4 ModelView : state.matrix.modelview,
            uniform float4x4 ModelViewProj : state.matrix.mvp)
          {
            vertex2fragment OUT;
            OUT.Hposition = mul (ModelViewProj, IN.Position);
            OUT.position_camera = mul (ModelView, IN.Position);
            OUT.TexCoord = IN.TexCoord;
            return OUT;
          }
          ]]>
          </program>
        </cgvp>
      </vp>
      <fp plugin="glcg">
        <cgfp>
        <variablemap variable="pass color" destination="passColor" />
        <variablemap variable="light numSplits" destination="numSplits" />        
        <variablemap variable="mrt" destination="mrt" />        
        <variablemap variable="light shadow map projection" destination="projection" />   
        <program>
          <![CDATA[
          float passColor[64];
          int numSplits;
          int mrt;
          float4x4 projection;
          struct vertex2fragment {
            float4 Hposition : POSITION;
            float2 TexCoord : TEXCOORD0;
            float4 position_camera : TEXCOORD1;
          };  
          struct fragmentOutput
          {
            float4 Color0 : COLOR0;
          ]]>            
        <?if vars."mrt".int &gt; 1?>
          <![CDATA[          
            float4 Color1 : COLOR1;
            float4 Color2 : COLOR2;
            float4 Color3 : COLOR3;
          ]]>            
        <?if vars."mrt".int &gt; 4?>
          <![CDATA[          
            float4 Color4 : COLOR4;
            float4 Color5 : COLOR5;
            float4 Color6 : COLOR6;
            float4 Color7 : COLOR7;
          ]]>
        <?endif?>
        <?endif?>
          <![CDATA[               
          };
          fragmentOutput main (vertex2fragment IN,
            uniform sampler2D TexDiffuse,
            uniform sampler2D DepthMap)
          {
            fragmentOutput output;
            float4 surface = tex2D (TexDiffuse, IN.TexCoord);
            
            float value = surface.a;

            // compute the projection for the depth map
            float4x4 flipY;
            flipY[0] = float4 (1, 0, 0, 0);
            flipY[1] = float4 (0, -1, 0, 0);
            flipY[2] = float4 (0, 0, 1, 0);
            flipY[3] = float4 (0, 0, 0, 1);
            float4x4 proj = mul (flipY, projection);
            float4 shadowMapCoords = mul (proj, IN.position_camera);            
            float4 shadowMapCoordsProj = shadowMapCoords;
            shadowMapCoordsProj.xyz /= shadowMapCoordsProj.w;                
            float3 shadowMapCoordsBiased = (float3(0.5)*shadowMapCoordsProj.xyz) 
              + float3(0.5);
            float2 position = shadowMapCoordsBiased.xy;
            
            float compareDepth = (1 - shadowMapCoordsBiased.z);
            float depth = tex2D(DepthMap, position).x;
    
            if (position.x < 0 || position.y < 0 || position.x > 1 || position.y > 1)
              depth = 0;    
    
            int i;
            if (depth == 0)
              return output;
            
            i = min((1 - (compareDepth + 0.03 - depth) * 4) * numSplits, numSplits - 1);  

//            int i = (abs(depth) - abs(compareDepth)) * 32;
/*            
            if (projection[0][0] == 0)
              mrt = 1;              

            int i;
            for (i = 0 ; i < numSplits ; i ++)
              if (passColor[i] > IN.position_camera.z)
                break;
*/
            int index = i % 4;
            float4 color = value;
            color = color * float4(index < 1, index < 2, index < 3, 1);
            
            // write in the correct render target
            int renderTarget = (i / 4) % mrt;
            
            output.Color0 = color * (renderTarget == 0);
          ]]>            
        <?if vars."mrt".int &gt; 1?>
          <![CDATA[                      
            output.Color1 = color * (renderTarget == 1);
            output.Color2 = color * (renderTarget == 2);
            output.Color3 = color * (renderTarget == 3);
          ]]>            
        <?if vars."mrt".int &gt; 4?>
          <![CDATA[                      
            output.Color4 = color * (renderTarget == 4);
            output.Color5 = color * (renderTarget == 5);
            output.Color6 = color * (renderTarget == 6);
            output.Color7 = color * (renderTarget == 7);
            ]]>
        <?endif?>
        <?endif?>
          <![CDATA[     
            return output;
          }
          ]]>
          </program>
        </cgfp>
      </fp>      
    </pass>
  </technique>
  
</shader>
