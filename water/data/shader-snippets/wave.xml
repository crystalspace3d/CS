<snippet>
	<technique priority="100">
		<combiner name="cg" plugin="crystalspace.graphics3d.shader.combiner.glcg" />
		<combiner name="glsl" plugin="crystalspace.graphics3d.shader.combiner.glsl"/>
     
		<input name="Hposition" type="position4_object" default="complex">
			<block location="cg:vertexIn">
				<varying type="position4" name="Hposition" binding="POSITION" />
			</block>
			<block location="cg:vertexMain">Hposition = vertexIn.Hposition;</block>
			<block location="glsl:inputs">
				<!-- varying type="position4" name="gl_Position"/ -->
			</block>
			<block location="glsl:vertexMain">Hposition = gl_Vertex;</block>  
		</input>
    
		<!-- Slightly dirty: float4x4 is no weaver type, so gets written out 
		verbatim -->
		<input file="/shader-snippets/ModelViewProj.inp" private="yes" />
		<input file="/shader-snippets/ModelView.inp" private="yes" />
	
		<input name="objectToWorld" type="float4x4" default="complex" private="yes">
			<block location="cg:vertexIn">
				<uniform type="float4x4" name="objectToWorld"/>
			</block>
			<block location="glsl:inputs">
				<uniform type="float4x4" name="in_objectToWorld"/>
			</block>
			<block location="cg:fragmentIn">
				<uniform type="float4x4" name="objectToWorld"/>
			</block>
			<block location="cg:vertexMain">objectToWorld = vertexIn.objectToWorld;</block>
			<block location="glsl:vertexMain">objectToWorld = in_objectToWorld;</block>
			<block location="cg:fragmentMain">objectToWorld = fragmentIn.objectToWorld;</block>
			<block location="glsl:fragmentMain">objectToWorld = in_objectToWorld;</block>
			<block location="cg:variablemap">
				<variablemap variable="object2world transform" destination="vertexIn.objectToWorld"/>
				<variablemap variable="object2world transform" destination="fragmentIn.objectToWorld"/>
			</block>
			<block location="glsl:variablemap">
				<variablemap variable="object2world transform" destination="in_objectToWorld"/>
			</block>
		</input>
	
		<block location="cg:variablemap">
			<variablemap variable="phases" destination="waveInput.phases" />
			<variablemap variable="amps" destination="waveInput.amps" />
			<variablemap variable="freqs" destination="waveInput.freqs" />
			<variablemap variable="kys" destination="waveInput.kys" />
			<variablemap variable="kxs" destination="waveInput.kxs" />
			<variablemap variable="standard time" destination="waveInput.time" />
		</block>
		
		<block location="glsl:variablemap">
			<variablemap variable="phases" destination="waveInput.phases" />
			<variablemap variable="amps" destination="waveInput.amps" />
			<variablemap variable="freqs" destination="waveInput.freqs" />
			<variablemap variable="kys" destination="waveInput.kys" />
			<variablemap variable="kxs" destination="waveInput.kxs" />
			<variablemap variable="standard time" destination="waveInput.time" />
		</block>
		
		
		<block location="cg:vertexToFragment">
			<varying type="position4" name="position" binding="POSITION" />
			<!-- This is needed since POSITION semantics can't be used for input in an FP -->
			<varying type="position4" name="position_screen" />
			<varying type="position4" name="position_object"/>
			<varying type="position4" name="position_world"/>
			<varying type="position4" name="position_camera"/>
		</block>
		
		<block location="glsl:vertexToFragment">
			<varying type="position4" name="position"/>
			<varying type="position4" name="position_screen"/>
			<varying type="position4" name="position_object"/>
			<varying type="position4" name="position_world"/>
			<varying type="position4" name="position_camera"/>
		</block>
		
		<block location="cg:clips">
			<!-- Clip for reflection/refraction rendering -->
			<clip space="object">
				<plane type="shadervar">clip plane reflection</plane>
			</clip>
		</block>
		
		<block location="cg:vertexCompilerArgs">
			-posinv
		</block>
		
		<block location="cg:definitions">
			<?Include /shader-snippets/cg-global_objectToWorld.cginc?> 
			struct WaveIn
			{
				float3 amps; 
				float3 kxs; 
				float3 kys;  
				float3 freqs; 
				float3 phases;
				float time;
			};
			uniform WaveIn waveInput;
		
		
			//Wave displacement x-z
			float2 WaveDisp(float2 k, float amp, float2 pos, float freq, float phase, float time) 
			{ 
				float2 normk = normalize(k);
				return normk * amp * sin(dot(k, pos) - (freq * time) + phase);
			}
	
			//Wave displacement y
			float WaveDispVert(float2 k, float amp, float2 pos, float freq, float phase, float time)
			{
				return amp * cos(dot(k, pos) - (freq * time) + phase);
			}	
		</block>
		
		<block location="glsl:definitions">
			<?Include /shader-snippets/glsl-global_objectToWorld.glsli?>	  
		
			struct WaveIn
			{
				float3 amps; 
				float3 kxs; 
				float3 kys;  
				float3 freqs; 
				float3 phases;
				float time;
			};
			uniform WaveIn waveInput;
		
		
			//Wave displacement x-z
			float2 WaveDisp(float2 k, float amp, float2 pos, float freq, float phase, float time) 
			{	 
				float2 normk = normalize(k);
				return normk * amp * sin(dot(k, pos) - (freq * time) + phase);
			}
	
			//Wave displacement y
			float WaveDispVert(float2 k, float amp, float2 pos, float freq, float phase, float time)
			{
				return amp * cos(dot(k, pos) - (freq * time) + phase);
			}		
		</block>
		
		<block location="cg:vertexMain">
			position_object = Hposition;
		
			//Grab xz position
			float2 xzpos = mul(objectToWorld, position_object).xz;
	
			//Displace once
			float2 k = float2(waveInput.kxs.x, waveInput.kys.x);
			float2 wdxz1 = WaveDisp(k, waveInput.amps.x, xzpos, waveInput.freqs.x, waveInput.phases.x, waveInput.time);
			float wdy1 = WaveDispVert(k, waveInput.amps.x, xzpos, waveInput.freqs.x, waveInput.phases.x, waveInput.time);
			
			//Displace twice
			k = float2(waveInput.kxs.y, waveInput.kys.y);
			float2 wdxz2 = WaveDisp(k, waveInput.amps.y, xzpos, waveInput.freqs.y, waveInput.phases.y, waveInput.time);
			float wdy2 = WaveDispVert(k, waveInput.amps.y, xzpos, waveInput.freqs.y, waveInput.phases.y, waveInput.time);
			
			//Displace thrice, three times displacement!
			k = float2(waveInput.kxs.z, waveInput.kys.z);
			float2 wdxz3 = WaveDisp(k, waveInput.amps.z, xzpos, waveInput.freqs.z, waveInput.phases.z, waveInput.time);
			float wdy3 = WaveDispVert(k, waveInput.amps.z, xzpos, waveInput.freqs.z, waveInput.phases.z, waveInput.time);
		
			//Add all the displacements
			position_object.x -= wdxz1.x + wdxz2.x + wdxz3.x;
			position_object.z -= wdxz1.y + wdxz2.y + wdxz3.y;
			position_object.y = wdy1 + wdy2 + wdy3; 
			
			position_screen = position = mul (ModelViewProj, position_object);
			position_camera = mul (ModelView, position_object);
			position_world = mul (objectToWorld, position_object);
			
			APPLY_CLIPPING_VP_POSINV(position_camera, position_world, position_object);
		
			/* The objectToWorld transform is needed in other places, so there is a 
			global variable for it. Set that */
			SetGlobalObjectToWorld (objectToWorld);
		</block>
		
		<block location="glsl:vertexMain">
			position_object = Hposition;
		
			//Grab xz position
			float2 xzpos = (objectToWorld * position_object).xz;
		
			//Displace once
			float2 k = float2(waveInput.kxs.x, waveInput.kys.x);
			float2 wdxz1 = WaveDisp(k, waveInput.amps.x, xzpos, waveInput.freqs.x, waveInput.phases.x, waveInput.time);
			float wdy1 = WaveDispVert(k, waveInput.amps.x, xzpos, waveInput.freqs.x, waveInput.phases.x, waveInput.time);
			
			//Displace twice
			k = float2(waveInput.kxs.y, waveInput.kys.y);
			float2 wdxz2 = WaveDisp(k, waveInput.amps.y, xzpos, waveInput.freqs.y, waveInput.phases.y, waveInput.time);
			float wdy2 = WaveDispVert(k, waveInput.amps.y, xzpos, waveInput.freqs.y, waveInput.phases.y, waveInput.time);
			
			//Displace thrice, three times displacement!
			k = float2(waveInput.kxs.z, waveInput.kys.z);
			float2 wdxz3 = WaveDisp(k, waveInput.amps.z, xzpos, waveInput.freqs.z, waveInput.phases.z, waveInput.time);
			float wdy3 = WaveDispVert(k, waveInput.amps.z, xzpos, waveInput.freqs.z, waveInput.phases.z, waveInput.time);
		
			//Add all the displacements
			position_object.x -= wdxz1.x + wdxz2.x + wdxz3.x;
			position_object.z -= wdxz1.y + wdxz2.y + wdxz3.y;
			position_object.y = wdy1 + wdy2 + wdy3; 
			
			gl_Position = position_screen = position = (ModelViewProj * position_object);
			position_camera = ModelView * position_object;
			position_world = objectToWorld * position_object;
			
			//APPLY_CLIPPING_VP_POSINV(position_camera, position_world, position_object);
		
			/* The objectToWorld transform is needed in other places, so there is a 
			global variable for it. Set that */
			SetGlobalObjectToWorld (objectToWorld);
		</block>
		
		<block location="cg:fragmentMain">
			APPLY_CLIPPING_FP_POSINV; /* The objectToWorld transform is needed in other places, so there is a global variable for it. Set that */ SetGlobalObjectToWorld (objectToWorld); position = position_screen;
		</block>
		<block location="glsl:fragmentMain">
			//APPLY_CLIPPING_FP_POSINV; /* The objectToWorld transform is needed in other places, so there is a global variable for it. Set that */ SetGlobalObjectToWorld (objectToWorld); position = position_screen;
		</block>
		
		<output name="position" type="position4_screen" />
		<!-- @@@ FIXME: Other blocks may need the world space input as well... 
			Pass through. But is there a better (ie automatic) way? -->
		<output name="position_world" type="position4_world" />
		<output name="position_object" type="position4_object" />
		<output name="position_camera" type="position4_camera" />
	</technique>
</snippet>
